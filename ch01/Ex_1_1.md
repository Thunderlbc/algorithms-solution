#Basic Programming Model

##1.1.1

a) 7

b) 200.0000002

c) true

##1.1.2

a) double, 1.618

b) double, 10.0

c) boolean, true

d) String, "33"

##1.1.3

```
public class Main {
    public static void main(String[] args) {
        int a = Integer.parseInt(args[0]);
        int b = Integer.parseInt(args[1]);
        int c = Integer.parseInt(args[2]);
        if ((a == b) && (a == c)) {
            StdOut.println("equal");
        } else {
            StdOut.println("not equal");
        }
    }
}
```
##1.1.4

a) wrong

b) wrong

c) right

d) wrong

##1.1.5

``((x>0) && (y>0) && (x<1) && (y<1)) ? true : false``

##1.1.6

```
0
1
1
2
3
5
8
13
21
34
55
89
144
233
377
610
```

##1.1.7

a) 3.0009, Newton's method for finding roots

b) 499500

c) 10000

##1.1.8

a) b

b) 197 (cast char into int)

c) e (first cast into int, after add up , cast into char)

##1.1.9

```
String s = "";
for(int n=N; n>0; n /= 2){
    s = (n % 2) + s;
}
```

##1.1.10

array should be *initialized* before get/set its element(by using the *new* statement in Java)

##1.1.11

```
public class sln_1_1_11 {
    public static void main(String[] args){
        boolean[][] lis = {
                {true, false, true},
                {false, true, true, false},
                {false, true}
        };
        int MaxLength = lis[0].length;
        for (int l = 1; l < lis.length; l++) {
            if (MaxLength < lis[l].length)
                MaxLength = lis[l].length;
        }
        for(int i = 0; i < MaxLength; ++i){
            System.out.printf(" |");
            System.out.printf( i + "|");
        }
        System.out.printf("\n");
        for (int j = 0; j < lis.length; j++) {
            System.out.printf(j + "");
            for (int k = 0; k < lis[j].length; k++) {
                System.out.printf(lis[j][k] ? "|*| ":"| | ");
            }
            System.out.printf("\n");
        }
    }
}
```


##1.1.12

from the last two line codes, we can see the result has nothing to do with array ``a``.
(but, why bother?)

```
for(int i=0; i<10; i++)
    System.out.println(i);
```

##1.1.13

```
public class Main {
    private static void printArray(int[][] a) {
        for (int i = 0; i < a.length; i++) {
            for (int j = 0; j < a[0].length; j++) {
                StdOut.print(a[i][j] + ",");
            }
            StdOut.println();
        }
    }
    public static int[][] transform(int[][] a) {
        int[][] a_T = new int[a[0].length][a.length];
        for (int i = 0; i < a[0].length; i++) {
            for (int j = 0; j < a.length; j++) {
                a_T[i][j] = a[j][i];
            }
        }
        return a_T;
    }
    public static void main(String[] args) {
        int m = 3, n = 5;
        int[][] a = new int[m][n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                a[i][j] = StdRandom.uniform(3);
            }
        }
        StdOut.println("array before transform:");
        printArray(a);
        StdOut.println("array after transform:");
        printArray(transform(a));
    }
}
```

##1.1.14

```
public class Main {
    public static int lg(int n){
        int count=0;
        while(n != 1){
            n /= 2;
            count += 1;
        }
        return count;
    }
    public static void main(String[] args) {
        int n = StdIn.readInt();
        StdOut.printf("Input: %d\n", n);
        StdOut.printf("Standard output: %.5f\n", Math.log(n)/Math.log(2));
        StdOut.printf("My answer: %d\n", lg(n));
    }
}
```

##1.1.15

```
import java.util.Arrays;

public class Main {
    public static int[] histogram(int[] a, int m) {
        int[] hist = new int[m];
        for (int x : a) {
            hist[x] += 1;
        }
        return hist;
    }

    public static void main(String[] args) {
        int[] a = new int[]{1, 1, 2, 2, 2, 3, 3, 3, 3};
        int m = 4;
        StdOut.println(Arrays.toString(histogram(a, m)));
    }
}
```

##1.1.16

311361142246

##1.1.17

The stop condition must be reached!

##1.1.18

Given a and b, mystery(a, b) is a*b. Let's take mystery(3, 11) as example.
11 can be expressed as its binary code 1011b.Then it will make sense.

Similarly, if we change + into * and change ``return 0`` into ``return 1``,
we can get mystery(a,b) is a^b.

##1.1.19

```
public class Main {
    public static long F(int N) {
        if (N == 0) return 0;
        if (N == 1) return 1;
        long[] f = new long[N + 1];
        f[0] = 0;
        f[1] = 1;
        for (int i = 2; i < N + 1; i++) {
            f[i] = f[i - 1] + f[i - 2];
        }
        return f[N];
    }

    public static void main(String[] args) {
        for (int N = 0; N < 100; N++) {
            StdOut.println(N + " " + F(N));
        }
    }
}
```

##1.1.20

```
public class Main {
    public static double lnFactorial(int N) {
        if (N == 1) return 0;
        return lnFactorial(N-1) + Math.log(N);
    }

    public static void main(String[] args) {
        int N = 10;
        long r = 1;
        for(int i=0; i<N; i++){
            r *= i+1;
        }
        StdOut.printf("My result: %.5f\n",lnFactorial(N));
        StdOut.printf("Supposed: %.5f\n",Math.log(r));
    }
}
```

##1.1.21

```
public class Main {
    public static void main(String[] args) {
        while(!StdIn.isEmpty()){
            String name = StdIn.readString();
            int i1 = StdIn.readInt();
            int i2 = StdIn.readInt();
            if(i2 == 0) continue;
            StdOut.printf("%10s | %10d | %10d | %10f\n", name, i1, i2, (double)i1/i2);
        }
    }
}
```

##1.1.22

```
import java.util.Arrays;

public class Main {
    public static int rank(int key, int[] a) {
        return rank(key, a, 0, a.length - 1, 0);
    }

    public static int rank(int key, int[] a, int lo, int hi, int depth) {
        StdOut.println(new String(new char[depth]).replace('\0', '*')+  lo + "," + hi);
        if (lo > hi) return -1;
        int mid = lo + (hi - lo) / 2;
        if (key < a[mid]) return rank(key, a, lo , mid - 1, depth + 1);
        else if (key > a[mid]) return rank(key, a, mid + 1, hi, depth + 1);
        else return mid;
    }

    public static void main(String[] args) {
        int[] a = new int[]{3,5,8,1,4,7,2};
        Arrays.sort(a);
        StdOut.println(Arrays.toString(a));
        StdOut.println(rank(3, a));
    }
}
```

##1.1.23

```
while (!StdIn.isEmpty()) {
    int key = StdIn.readInt();
    if (rank(key, whitelist) == -1) {
        StdOut.print(key);
        StdOut.println("+");
    }
    else{
        StdOut.println("-");
    }
}
```

##1.1.24

1

```
public class Main {
    public static int gcd(int p, int q){
//        assert p >= q;
        StdOut.println(p + "," + q);
        if(q == 0) return p;
        int r = p % q;
        return gcd(q, r);
    }
    public static void main(String[] args) {
        int a = StdIn.readInt();
        int b = StdIn.readInt();
        StdOut.println(gcd(a, b));
    }
}
```

##1.1.25

given a, b. suppose c is the greatest common divisor.

``a = kb + r (1)``

``a = mc (2)``

``b = nc (3)``

from (1), (2) we can get ``r = mc - kb``, with (3) we can get

``r = (m-kn)c``

This means r has the same c(the greatest common divisor) with b.
However, r is less than a. So we can get much closer to c.

In the end, we can always get the c.


